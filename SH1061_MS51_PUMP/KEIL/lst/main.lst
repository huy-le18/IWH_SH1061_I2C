C51 COMPILER V9.60.7.0   MAIN                                                              04/15/2024 19:23:13 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Output\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\main.c LARGE OMF2 OPTIMIZE(7,SPEED) BROWSE INCDIR(..\driver;..\driver
                    -\driver_debug\inc;..\library\library_app\inc;..\library\library_debug\inc;..\driver\driver_app\inc;..\library\library_i2
                    -c\inc) DEBUG PRINT(.\lst\main.lst) TABS(2) OBJECT(.\Output\main.obj)

line level    source

   1          /*--------------------------------------------------------------------------------------------------------
             --*/
   2          /*                                                                                                        
             - */
   3          /* SPDX-License-Identifier: Apache-2.0                                                                    
             - */
   4          /* Copyright(c) 2020 Nuvoton Technology Corp. All rights reserved.                                        
             - */
   5          /*                                                                                                        
             - */
   6          /*--------------------------------------------------------------------------------------------------------
             --*/
   7          #include "main.h"
   8          
   9          #define CYCLE_FOR_ELCB                17
  10          #define CYCLE_FOR_RESET_ELCB          20
  11          #define FLAG_WRITE          0
  12          #define FLAG_READ           1
  13          
  14          // define error send from master
  15          #define CONNECT_UI_BOARD_ERR_BIT 0
  16          #define OUT_TEMP_HIGHT_ERR_BIT 1
  17          #define FLOW_LOW_ERR_BIT 2
  18          #define TESTING_CB_NOTIFY_BIT 3
  19          #define ADC_OUTPUT_ERR_BIT 4
  20          #define ADC_INPUT_ERR_BIT 5
  21          
  22          #define MAX_FLOW_SAMPLE   5
  23          #define MAX_TIN_SAMPLE    14
  24          
  25          unsigned int FULSE_Tset_to_55[MAX_TIN_SAMPLE][5] = 
  26          {
  27          //   23   28   33   38   43
  28            {309, 325 ,373, 390, 406},   // 16
  29            {294, 303 ,370, 387, 404},   // 18
  30            {280, 297 ,368, 385, 403},   // 20
  31            {265, 293 ,348, 385, 403},   // 22
  32            {233, 291 ,329, 368, 407},   // 24
  33            {228, 269 ,311, 352, 414},   // 26
  34            {203, 270 ,293, 338, 383},   // 28
  35            {175, 225 ,250, 325, 360},   // 30
  36            {170, 230 ,240, 270, 350},   // 32
  37            {160, 220 ,230, 250, 330},   // 34
  38            {150, 200 ,210, 230, 270},   // 36
  39            {130, 170 ,190, 230, 230},   // 38
  40            {110, 140 ,170, 200, 230},   // 40
  41            {90 , 120 ,150, 180, 210}    // 42
  42          };
  43          
  44          unsigned char Flow_sample_arr[5] = {23, 28, 33, 38, 43};
  45          unsigned char Tin_sample_arr[MAX_TIN_SAMPLE] = {16,18,20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42};
  46          
  47          unsigned char Flow_sample_index_l;  // luu chi so thap
C51 COMPILER V9.60.7.0   MAIN                                                              04/15/2024 19:23:13 PAGE 2   

  48          unsigned char Flow_sample_index_h;  // luu chi so cao
  49          
  50          unsigned char Tin = 0;
  51          unsigned char Flow_in = 0;
  52          unsigned char Tset = 0;
  53          
  54          float F1, F2, F3, F4, F;
  55          unsigned int fulse;
  56          unsigned char delta_t_h;
  57          unsigned char delta_t_l;
  58          unsigned char i = 0;
  59          
  60          volatile bit b_boost;
  61          
  62          unsigned char u8_flag2msInTest = 0, u8_flag10msInTest = 0, u8_flag100msInTest = 0, u8_flag500msInTest = 0;
  63          unsigned char u8_flag2msInPower = 0, u8_flag10msInPower = 0, u8_flag100msInPower = 0, u8_flag500msInPower 
             -= 0;
  64          unsigned char u8_flag2msInPowerOnErr = 0, u8_flag10msInPowerOnErr = 0, u8_flag100msInPowerOnErr = 0, u8_fl
             -ag500msInPowerOnErr = 0;
  65          unsigned int g_u16CounterFlow = 0;
  66          unsigned int g_adcNtcIn = 0;
  67          unsigned int g_adcNtcOut = 0;
  68          unsigned char u8_elcbCounter = 0;
  69          unsigned char u8_restElcbCounter = 0;
  70          extern volatile unsigned char u8_value;
  71          extern volatile bit b_i2c_read_write;
  72          extern volatile bit b_flag_i2c_receive;
  73          extern volatile bit b_flag_i2c_transmit;
  74          extern volatile uint8_t u8_i2c_time_out;
  75          
  76          
  77          volatile bit b_test_cg;   // test chong giat
  78          volatile bit b_reset_cg;  // reset chong giat
  79          volatile uint8_t test_cg_cnt;
  80          volatile uint8_t reset_cg_cnt;
  81          
  82          volatile uint8_t machine_state = 0;
  83          
  84          DeviceMode_t deviceMode = DEVICE_MODE_POWER;
  85          DeviceModePower_t deviceModePower = DEVICE_MODE_POWER_OFF;
  86          DeviceModePowerOn_t deviceModePowerOn = DEVICE_MODE_POWER_ON_NORMAL; 
  87          
  88          
  89          volatile uint8_t cnt_clk = 0;
  90          volatile uint8_t data_rx;
  91          volatile uint8_t m_tx_data[3];
  92          volatile uint8_t m_rx_data[3];
  93          volatile uint8_t temp_out;
  94          volatile uint8_t temp_in;
  95          volatile uint8_t temp_set;
  96          volatile unsigned char data_handle[2];
  97          
  98          volatile bit b_last_state = 1;
  99          volatile bit b_state = 0;
 100          volatile bit b_data = 0;
 101          volatile bit b_test = 0;
 102          volatile bit b_reset = 0;
 103          volatile bit b_cg_in_mode_test = 0;
 104          volatile bit b_cg_in_mode_power = 0;
 105          
 106          uint8_t datas;
 107          
C51 COMPILER V9.60.7.0   MAIN                                                              04/15/2024 19:23:13 PAGE 3   

 108          void main(void) {
 109   1        uart_sw_init();
 110   1        task_init();
 111   1        flow_counter_init();
 112   1        ntc_in_adc_init();
 113   1        ntc_out_adc_init();
 114   1        ntc_in_select_channel();
 115   1        
 116   1        lo_output_init();
 117   1        reset_lo_output_init();
 118   1        int_os_input_init();
 119   1        ctr_outac_output_init();
 120   1        ctr_triac_output_init();
 121   1        
 122   1        lo_write_low();
 123   1        reset_lo_write_low();
 124   1        ctr_outac_write_low();
 125   1        ctr_triac_write_high();
 126   1        
 127   1        i2c_init_interrupt();
 128   1        gpio_interrupt_init();
 129   1        
 130   1        
 131   1        
 132   1        while (1) 
 133   1        {
 134   2          
 135   2          if(u8_flag_200us == 1)
 136   2          {
 137   3            u8_flag_200us = 0;
 138   3          }
 139   2          if(u8_flag_1ms == 1)
 140   2          {
 141   3            u8_flag_1ms = 0;
 142   3          }
 143   2          if(u8_flag_2ms == 1)
 144   2          {
 145   3            u8_flag_2ms = 0;
 146   3            
 147   3            
 148   3            /*check flag adc*/
 149   3            if(u8_flag_adc == 1)
 150   3            {
 151   4              u8_flag_adc = 0;
 152   4              
 153   4              switch (adc_get_ntc_in_or_ntc_out())
 154   4              {
 155   5                case ADC_CHANNEL_NTC_IN:
 156   5                  g_adcNtcIn = convert12BitsTo10Bit(u16_adc_value);
 157   5                  ntc_out_select_channel();
 158   5                  break;
 159   5                case ADC_CHANNEL_NTC_OUT:
 160   5                  g_adcNtcOut = convert12BitsTo10Bit(u16_adc_value);
 161   5                  ntc_in_select_channel();
 162   5                  break;
 163   5                default:
 164   5                  break;
 165   5              }
 166   4              
 167   4              
 168   4            }
 169   3            
C51 COMPILER V9.60.7.0   MAIN                                                              04/15/2024 19:23:13 PAGE 4   

 170   3            if ((g_adcNtcIn > ADC_HIGH_LIMIT) || (g_adcNtcIn < ADC_LOW_LIMIT)) {
 171   4              machine_state |= (1 << ADC_INPUT_ERR_BIT);
 172   4      
 173   4            } else {
 174   4              machine_state &= ~(1 << ADC_INPUT_ERR_BIT);
 175   4            }
 176   3            
 177   3            
 178   3            if ((g_adcNtcOut > ADC_HIGH_LIMIT) || (g_adcNtcOut < ADC_LOW_LIMIT)) {
 179   4              machine_state |= (1 << ADC_OUTPUT_ERR_BIT);
 180   4      
 181   4            } else {
 182   4              machine_state &= ~(1 << ADC_OUTPUT_ERR_BIT);
 183   4            }
 184   3            
 185   3            
 186   3            if(g_adcNtcIn < 384) 
 187   3            {
 188   4              g_adcNtcIn = 384;
 189   4            }
 190   3            
 191   3            if(g_adcNtcOut < 384) 
 192   3            {
 193   4              g_adcNtcOut = 384;
 194   4            }
 195   3            
 196   3            /*handle temperature*/
 197   3            getTempFromTable((uint16_t)g_adcNtcIn, &temp_in);
 198   3            getTempFromTable((uint16_t)g_adcNtcOut, &temp_out);
 199   3            
 200   3            
 201   3            if ((temp_out > TEMP_MIN_TO_PROTECT)) {
 202   4              machine_state |= (1 << OUT_TEMP_HIGHT_ERR_BIT);
 203   4      
 204   4            } else {
 205   4              machine_state &= ~(1 << OUT_TEMP_HIGHT_ERR_BIT);
 206   4            }
 207   3            
 208   3            
 209   3            /*process main programer*/
 210   3            switch (deviceMode)
 211   3            {
 212   4              case DEVICE_MODE_START:
 213   4      
 214   4                break;
 215   4              case DEVICE_MODE_TEST:
 216   4                if(int_os_read_state() == 0)
 217   4                {
 218   5                  ctr_outac_write_low();
 219   5                  machine_state |= (1 << TESTING_CB_NOTIFY_BIT);
 220   5                  b_cg_in_mode_test = 1;
 221   5                }
 222   4                else
 223   4                {
 224   5                  machine_state &= ~(1 << TESTING_CB_NOTIFY_BIT);
 225   5                  b_cg_in_mode_test = 0;
 226   5                }
 227   4                break;
 228   4              case DEVICE_MODE_POWER:
 229   4      
 230   4                if(int_os_read_state() == 0)
 231   4                {
C51 COMPILER V9.60.7.0   MAIN                                                              04/15/2024 19:23:13 PAGE 5   

 232   5                  ctr_outac_write_low();
 233   5                  fulse = 0;
 234   5                  u16NumActive = 0;
 235   5                  num_active_pulse = 0;
 236   5                  num_addition = 0;
 237   5                  
 238   5                  machine_state |= (1 << TESTING_CB_NOTIFY_BIT);
 239   5                  b_cg_in_mode_power = 1;
 240   5                  
 241   5                }
 242   4                else
 243   4                {
 244   5                  machine_state &= ~(1 << TESTING_CB_NOTIFY_BIT);
 245   5                  b_cg_in_mode_power = 0;
 246   5                }
 247   4                break;
 248   4            }
 249   3          }
 250   2          
 251   2          if(u8_flag_10ms == 1)
 252   2          {
 253   3            u8_flag_10ms = 0;
 254   3            
 255   3            // test chong giat
 256   3            if (b_test_cg == 1) {
 257   4              if (test_cg_cnt < 17) {
 258   5                lo_write_tonggle();
 259   5                test_cg_cnt++;
 260   5              } else {
 261   5                b_test_cg = 0;
 262   5                test_cg_cnt = 0;
 263   5                lo_write_low();
 264   5              }
 265   4            }
 266   3            
 267   3            // reset chong giat
 268   3            if (b_reset_cg == 1) {
 269   4              if (reset_cg_cnt < 30) {
 270   5                reset_cg_cnt++;
 271   5                reset_lo_write_high();
 272   5              } else {
 273   5                b_reset_cg = 0;
 274   5                reset_cg_cnt = 0;
 275   5                reset_lo_write_low();
 276   5              }
 277   4            }
 278   3            
 279   3            if(b_flag_i2c_receive == 1)
 280   3            {
 281   4              if(m_rx_data[2] == CRC8(m_rx_data, 2))
 282   4              {
 283   5                data_handle[0] = m_rx_data[0];
 284   5                data_handle[1] = m_rx_data[1];
 285   5                 
 286   5                temp_set = data_handle[1];
 287   5                if(data_handle[0] & (1 << CMD_TEST_BIT))
 288   5                {
 289   6              
 290   6                  deviceMode = DEVICE_MODE_TEST;
 291   6                  b_test_cg = 1;
 292   6                  
 293   6                  ctr_outac_write_low();
C51 COMPILER V9.60.7.0   MAIN                                                              04/15/2024 19:23:13 PAGE 6   

 294   6                  
 295   6                }
 296   5                else if(data_handle[0] & (1 << CMD_RESET_BIT))
 297   5                {
 298   6                  deviceMode = DEVICE_MODE_POWER;
 299   6                  
 300   6                  b_reset_cg = 1;
 301   6                }
 302   5                
 303   5                if(temp_set == 0)
 304   5                {
 305   6                  deviceModePower = DEVICE_MODE_POWER_OFF;
 306   6                }
 307   5                else if(temp_set > 0)
 308   5                {
 309   6                  deviceModePower = DEVICE_MODE_POWER_ON;
 310   6                }
 311   5      
 312   5                b_flag_i2c_receive = 0;
 313   5              }
 314   4            }
 315   3            
 316   3            
 317   3            switch (deviceMode)
 318   3            {
 319   4              case DEVICE_MODE_START:
 320   4      
 321   4                break;
 322   4              case DEVICE_MODE_TEST:
 323   4                
 324   4                fulse = 0;
 325   4                u16NumActive = 0;
 326   4                num_active_pulse = 0;
 327   4                num_addition = 0;
 328   4              
 329   4                ctr_outac_write_low();
 330   4                
 331   4                
 332   4                break;
 333   4              case DEVICE_MODE_POWER:
 334   4                
 335   4                break;
 336   4            }
 337   3            
 338   3          }
 339   2          
 340   2          if(u8_flag_50ms == 1)
 341   2          {
 342   3            u8_flag_50ms = 0;
 343   3            
 344   3            if(b_i2c_read_write == FLAG_WRITE)
 345   3            {
 346   4              m_tx_data[0] = machine_state;
 347   4              m_tx_data[1] = temp_out;
 348   4              m_tx_data[2] = CRC8(m_tx_data, 2);  
 349   4              i2c_master_write();
 350   4            }
 351   3            else if (b_i2c_read_write == FLAG_READ)
 352   3            {
 353   4              i2c_master_read();
 354   4            }
 355   3            I2C_SET_START();
C51 COMPILER V9.60.7.0   MAIN                                                              04/15/2024 19:23:13 PAGE 7   

 356   3            I2C_CLEAR_SI();
 357   3          }
 358   2          
 359   2      //    if(u8_flag_100ms == 1)
 360   2      //    {
 361   2      //      u8_flag_100ms = 0;
 362   2      //    }
 363   2          
 364   2          if(u8_flag_200ms == 1)
 365   2          {
 366   3            u8_flag_200ms = 0;
 367   3            
 368   3            switch (deviceMode)
 369   3            {
 370   4              case DEVICE_MODE_START:
 371   4      
 372   4                break;
 373   4              case DEVICE_MODE_TEST:
 374   4                
 375   4                break;
 376   4              case DEVICE_MODE_POWER:
 377   4                
 378   4                switch (deviceModePower)
 379   4                {
 380   5                  case DEVICE_MODE_POWER_OFF:
 381   5                  
 382   5                    fulse = 0;
 383   5                    u16NumActive = 0;
 384   5                    num_active_pulse = 0;
 385   5                    num_addition = 0;
 386   5                    ctr_outac_write_low();
 387   5                  
 388   5                    break;
 389   5                  case DEVICE_MODE_POWER_ON:
 390   5            
 391   5                    if(machine_state & (1 << OUT_TEMP_HIGHT_ERR_BIT)
 392   5                      || machine_state & (1 << FLOW_LOW_ERR_BIT)
 393   5                      || machine_state & (1 << TESTING_CB_NOTIFY_BIT)
 394   5                      || machine_state & (1 << ADC_OUTPUT_ERR_BIT)
 395   5                      || machine_state & (1 << ADC_INPUT_ERR_BIT))
 396   5                    {
 397   6                      deviceModePowerOn = DEVICE_MODE_POWER_ON_ERR;
 398   6                    }
 399   5                    else
 400   5                    {
 401   6                      deviceModePowerOn = DEVICE_MODE_POWER_ON_NORMAL;
 402   6                    }
 403   5                  
 404   5                    switch (deviceModePowerOn)
 405   5                    {
 406   6                      case DEVICE_MODE_POWER_ON_NORMAL:
 407   6                        if(int_os_read_state() == 0)
 408   6                        {
 409   7                          ctr_outac_write_low();
 410   7                          fulse = 0;
 411   7                          u16NumActive = 0;
 412   7                          num_active_pulse = 0;
 413   7                          num_addition = 0;
 414   7                        
 415   7                          machine_state |= (1 << TESTING_CB_NOTIFY_BIT);
 416   7                          b_cg_in_mode_power = 1;
 417   7                          
C51 COMPILER V9.60.7.0   MAIN                                                              04/15/2024 19:23:13 PAGE 8   

 418   7                        }
 419   6                        else
 420   6                        {
 421   7                          ctr_outac_write_high();
 422   7                          machine_state &= ~(1 << TESTING_CB_NOTIFY_BIT);
 423   7                          b_cg_in_mode_power = 0;
 424   7                          mode_power_on_normal_program();
 425   7                        }
 426   6                        
 427   6                        break;
 428   6                      case DEVICE_MODE_POWER_ON_ERR:
 429   6                        fulse = 0;
 430   6                        u16NumActive = 0;
 431   6                        num_active_pulse = 0;
 432   6                        num_addition = 0;
 433   6                        ctr_outac_write_low();
 434   6                        
 435   6                        break;
 436   6                    }
 437   5                    
 438   5                    break;
 439   5                }
 440   4            
 441   4                break;
 442   4            }
 443   3            
 444   3          }
 445   2      //    if(u8_flag_500ms == 1)
 446   2      //    {
 447   2      //      u8_flag_500ms = 0;
 448   2      //      
 449   2      //      uart_sw_send_byte('\n');
 450   2      //      uart_sw_send_number(u16NumActive);
 451   2      //      uart_sw_send_byte('\n');
 452   2      ////      u8_detect_zero = 0;
 453   2      //      uart_sw_send_number(num_active_pulse);
 454   2      //      uart_sw_send_byte('\n');
 455   2      //      
 456   2      //      uart_sw_send_number(num_addition);
 457   2      //      uart_sw_send_byte('\n');
 458   2      //    }
 459   2          if(u8_flag_1s == 1)
 460   2          {
 461   3            u8_flag_1s = 0;
 462   3            
 463   3            g_u16CounterFlow = flow_counter_read();
 464   3            flow_counter_reset();
 465   3            
 466   3            if(g_u16CounterFlow < FLOW_MIN_TO_PROTECT)
 467   3            {
 468   4              machine_state |= (1 << FLOW_LOW_ERR_BIT);
 469   4            }
 470   3            else
 471   3            {
 472   4              machine_state &= ~(1 << FLOW_LOW_ERR_BIT);
 473   4            }
 474   3            
 475   3            
 476   3      //      uart_sw_send_byte('\n');
 477   3      //      machine_state
 478   3      //      uart_sw_send_number(machine_state);
 479   3      //      uart_sw_send_byte('\n');
C51 COMPILER V9.60.7.0   MAIN                                                              04/15/2024 19:23:13 PAGE 9   

 480   3      //      
 481   3            uart_sw_send_number(data_handle[0]);
 482   3            uart_sw_send_byte('\n');
 483   3            uart_sw_send_number(data_handle[1]);
 484   3            uart_sw_send_byte('\n');
 485   3            uart_sw_send_number(m_rx_data[2]);
 486   3            uart_sw_send_byte('\n');
 487   3            uart_sw_send_byte('\n');
 488   3      
 489   3      //      uart_sw_send_string("NtcI:",5);
 490   3      //      uart_sw_send_number(g_adcNtcIn);
 491   3      //      uart_sw_send_byte('\n');
 492   3      //      uart_sw_send_string("NtcO:",5);
 493   3      //      uart_sw_send_number(g_adcNtcOut);
 494   3      //      uart_sw_send_byte('\n');
 495   3      //      uart_sw_send_number(g_u16CounterFlow);
 496   3      //      uart_sw_send_byte('\n');
 497   3      //      
 498   3      //      uart_sw_send_string("tempi:",6);
 499   3      //      uart_sw_send_number(temp_in);
 500   3      //      uart_sw_send_byte('\n');
 501   3      //      uart_sw_send_string("tempo:",6);
 502   3      //      uart_sw_send_number(temp_out);
 503   3      //      uart_sw_send_byte('\n');
 504   3      //      uart_sw_send_string("temps:",6);
 505   3      //      uart_sw_send_number(temp_set);
 506   3      //      uart_sw_send_byte('\n');
 507   3      //      uart_sw_send_number(u16NumActive);
 508   3      //      uart_sw_send_byte('\n');
 509   3      //      uart_sw_send_byte('\n');
 510   3      //      uart_sw_send_string("ntc:",4);
 511   3      //      uart_sw_send_number(g_adcNtcValue);
 512   3      //      uart_sw_send_byte('\n');
 513   3      //      uart_sw_send_string("knob:",5);
 514   3      //      uart_sw_send_number(g_adcKnobValue);
 515   3      //      uart_sw_send_byte('\n');
 516   3      //      uart_sw_send_string("mode:",5);
 517   3      //      uart_sw_send_number(g_powerMode);
 518   3      //      uart_sw_send_byte('\n');
 519   3          }
 520   2          if(u8_flag_2s == 1)
 521   2          {
 522   3            u8_flag_2s = 0;
 523   3          }
 524   2        }
 525   1      }
 526          
 527          
 528          void mode_power_on_normal_program(void)
 529          {
 530   1              // calculate raw active pulse
 531   1            if (temp_set > 0) {
 532   2              /* Compute new control signal */
 533   2      
 534   2              Flow_in = g_u16CounterFlow;
 535   2              Tin = temp_in;
 536   2              
 537   2              for (i = 0; i < 5; i++) {
 538   3                if (Flow_in < Flow_sample_arr[0]) {
 539   4                  break;
 540   4                } else if ((Flow_in >= Flow_sample_arr[i]) && (Flow_in < Flow_sample_arr[i + 1])) {
 541   4                  Flow_sample_index_l = i;
C51 COMPILER V9.60.7.0   MAIN                                                              04/15/2024 19:23:13 PAGE 10  

 542   4                  Flow_sample_index_h = i + 1;
 543   4                  break;
 544   4                } else if ((Flow_in >= Flow_sample_arr[4])) {
 545   4                  Flow_sample_index_l = 3;
 546   4                  Flow_sample_index_h = 4;
 547   4                }
 548   3              }
 549   2      
 550   2              for (i = 0; i < MAX_TIN_SAMPLE; i++) {
 551   3                if (Tin < Tin_sample_arr[0]) {
 552   4                  F1 = FULSE_Tset_to_55[0][Flow_sample_index_l];
 553   4                  F2 = FULSE_Tset_to_55[0][Flow_sample_index_h];
 554   4                  break;
 555   4                } else if ((Tin >= Tin_sample_arr[i]) && (Tin < Tin_sample_arr[i + 1])) {
 556   4                  delta_t_l = FULSE_Tset_to_55[i][Flow_sample_index_l] - FULSE_Tset_to_55[i + 1][Flow_sample_ind
             -ex_l];
 557   4      
 558   4                  delta_t_h = FULSE_Tset_to_55[i][Flow_sample_index_h] - FULSE_Tset_to_55[i + 1][Flow_sample_ind
             -ex_h];
 559   4      
 560   4                  F1 = FULSE_Tset_to_55[i][Flow_sample_index_l] - (Tin - Tin_sample_arr[i]) * delta_t_l / 2.0;
 561   4      
 562   4                  F2 = FULSE_Tset_to_55[i][Flow_sample_index_h] - (Tin - Tin_sample_arr[i]) * delta_t_h / 2.0;
 563   4      
 564   4                  break;
 565   4                } else if ((Tin >= Tin_sample_arr[MAX_TIN_SAMPLE - 1])) {
 566   4                  F1 = FULSE_Tset_to_55[MAX_TIN_SAMPLE - 1][Flow_sample_index_l];
 567   4                  F2 = FULSE_Tset_to_55[MAX_TIN_SAMPLE - 1][Flow_sample_index_h];
 568   4                }
 569   3              }
 570   2      
 571   2              F4 = F1 - (F1 - F2) * (Flow_in - Flow_sample_arr[Flow_sample_index_l]) / 5.0;
 572   2              F = (temp_set - Tin) * F4 * 10 / (55 - Tin);
 573   2              if ((int)F % 10 >= 5) {
 574   3                fulse = F / 10 + 1;
 575   3              } else {
 576   3                fulse = F / 10;
 577   3              }
 578   2      
 579   2              if (temp_set > temp_in) {
 580   3                u16NumActive = fulse;
 581   3              } else
 582   2                u16NumActive = 0;
 583   2      
 584   2              if ((temp_out > temp_set)) {
 585   3                u16NumActive = u16NumActive * 9 / 10;
 586   3              }
 587   2              if ((temp_out < temp_set)) {
 588   3                if (temp_out < temp_set - 12) {
 589   4                  b_boost = 1;  
 590   4                }
 591   3                if (temp_out < temp_set - 6) {
 592   4                  if (b_boost == 1) u16NumActive = u16NumActive * 14 / 10;
 593   4                } else if (temp_out < temp_set - 1) {
 594   4                  if (b_boost == 1) u16NumActive = u16NumActive * 12 / 10;
 595   4                } else {
 596   4                  b_boost = 0;
 597   4                  u16NumActive = u16NumActive * 11 / 10;
 598   4                }
 599   3              }
 600   2      
 601   2              if (u16NumActive > 200) u16NumActive = 200;
C51 COMPILER V9.60.7.0   MAIN                                                              04/15/2024 19:23:13 PAGE 11  

 602   2              
 603   2              num_active_pulse = u16NumActive / 10;
 604   2              num_addition = u16NumActive - (num_active_pulse * 10);
 605   2      
 606   2              if (num_active_pulse > 20) {
 607   3                num_active_pulse = 20;
 608   3                num_addition = 0;
 609   3              }
 610   2            } else {
 611   2              u16NumActive = 0;
 612   2              num_active_pulse = 0;
 613   2              num_addition = 0;
 614   2            }
 615   1      }
 616          
 617          
 618          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2422    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    229    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     10    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
