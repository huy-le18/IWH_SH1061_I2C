C51 COMPILER V9.60.7.0   ISR                                                               04/15/2024 16:51:39 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE ISR
OBJECT MODULE PLACED IN .\Output\isr.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\library\library_app\src\isr.c LARGE OMF2 OPTIMIZE(7,SPEED) BROWSE INC
                    -DIR(..\driver;..\driver\driver_debug\inc;..\library\library_app\inc;..\library\library_debug\inc;..\driver\driver_app\in
                    -c;..\library\library_i2c\inc) DEBUG PRINT(.\lst\isr.lst) TABS(2) OBJECT(.\Output\isr.obj)

line level    source

   1          #include "ms51_16k.h"
   2          #include "driver_app.h"
   3          #include "library_app.h"
   4          // for intterupt 
   5          #include <intrins.h>
   6          
   7          #define C_1MS_CNT_VALUE 5
   8          #define ADDRESS_SLAVE   0xA0
   9          #define WRITE           0
  10          #define READ            1
  11          
  12          #define FLAG_WRITE          0
  13          #define FLAG_READ           1
  14          
  15          #define MAX_TRIAC_PULSE         20
  16          #define MAX_ADDITION_INTERVAL   10
  17          
  18          #define MAX_12MS_CNT 60
  19          
  20          
  21          // For 1ms Timer0 Interrupt use. To count global time 50us, 200us, 1ms, 10ms, 100ms, 500ms, 2s
  22          volatile unsigned char  u8_flag_200us = 0, u8_flag_1ms = 0, u8_flag_2ms = 0, u8_flag_10ms = 0, u8_flag_50ms
             - = 0;
  23          volatile unsigned char u8_flag_100ms = 0, u8_flag_200ms = 0, u8_flag_500ms = 0, u8_flag_1s = 0, u8_flag_2s
             - = 0; 
  24          volatile unsigned int u16_timer3_int_counter, u16_1ms_timer_counter, u16_2ms_timer_counter, u16_10ms_time_
             -counter, u16_50ms_time_counter;
  25          volatile unsigned int u16_100ms_time_counter, u16_200ms_time_counter,  u16_500ms_time_counter,u16_1s_time_
             -counter, u16_2s_time_counter;
  26          
  27          volatile unsigned int  u16_adc_value = 0;
  28          volatile unsigned char u8_flag_adc = 0;
  29          
  30          volatile bit b_i2c_read_write = FLAG_WRITE;
  31          
  32          extern volatile uint8_t m_tx_data[3];
  33          extern volatile uint8_t m_rx_data[3];
  34          
  35          volatile uint8_t u8_cnt_data_rx = 0;
  36          volatile uint8_t u8_cnt_data_tx = 0;
  37          
  38          volatile uint8_t addSlaveAndRW = ADDRESS_SLAVE|WRITE;
  39          
  40          volatile bit b_flag_i2c_receive = 0;
  41          volatile bit b_flag_i2c_transmit = 0;
  42          
  43          volatile uint8_t u8_i2c_time_out = 0;
  44          
  45          volatile uint8_t u8_detect_zero = 0;
  46          
  47          volatile uint8_t count12ms = 0;
  48          
  49          volatile uint8_t triac_pulse_cnt;
C51 COMPILER V9.60.7.0   ISR                                                               04/15/2024 16:51:39 PAGE 2   

  50          volatile uint8_t num_active_pulse;           // power from 0 to 20
  51          volatile uint8_t num_active_pulse_with_add;  // from 0 to 20
  52          volatile uint8_t pulse_trigger_off_cnt;
  53          volatile bit b_triggered;
  54          volatile uint8_t num_addition;
  55          volatile uint8_t additionInterval;
  56          volatile uint16_t u16NumActive;  // raw number of active pulse * 10
  57          
  58          
  59          void Timer3_ISR(void) interrupt 16        // Vector @  0x83
  60          {
  61   1        _push_(SFRS);
  62   1        clr_T3CON_TF3;
  63   1        u16_timer3_int_counter ++;  
  64   1        u8_flag_200us = 1;
  65   1        
  66   1        //---1ms-------------------------------------------
  67   1        if(u16_timer3_int_counter >= C_1MS_CNT_VALUE){            //1ms
  68   2          u16_timer3_int_counter = 0; 
  69   2          u16_1ms_timer_counter ++;
  70   2          u8_flag_1ms = 1;
  71   2        }
  72   1        //---2ms-------------------------------------------
  73   1          if(u16_1ms_timer_counter >= 2){                         //2ms
  74   2          u16_1ms_timer_counter = 0;
  75   2          u16_2ms_timer_counter ++; 
  76   2          u8_flag_2ms = 1;      
  77   2        }
  78   1          
  79   1        
  80   1        //---10ms-------------------------------------------
  81   1        if(u16_2ms_timer_counter >= 5){                         //10ms
  82   2          u16_2ms_timer_counter = 0;
  83   2          u16_10ms_time_counter ++; 
  84   2          u8_flag_10ms = 1;     
  85   2        }
  86   1        
  87   1        
  88   1          //---100ms------------------------------------------
  89   1        if(u16_10ms_time_counter >= 5){                         //100ms
  90   2          u16_10ms_time_counter = 0;
  91   2          u16_50ms_time_counter ++; 
  92   2          u8_flag_50ms = 1;
  93   2        }
  94   1        
  95   1        
  96   1        //---100ms------------------------------------------
  97   1        if(u16_50ms_time_counter >= 2){                         //100ms
  98   2          u16_50ms_time_counter = 0;
  99   2          u16_100ms_time_counter ++;  
 100   2          u8_flag_100ms = 1;
 101   2        }
 102   1        
 103   1        
 104   1        //---200ms------------------------------------------
 105   1        if(u16_100ms_time_counter >= 2){                          //200ms
 106   2          u16_100ms_time_counter = 0;
 107   2          u16_200ms_time_counter ++;  
 108   2          u8_flag_200ms = 1;
 109   2        }
 110   1        
 111   1      //  //---500ms------------------------------------------
C51 COMPILER V9.60.7.0   ISR                                                               04/15/2024 16:51:39 PAGE 3   

 112   1      //  if(u16_100ms_time_counter >= 5){                          //500ms
 113   1      //    u16_100ms_time_counter = 0;
 114   1      //    u16_500ms_time_counter ++;  
 115   1      //    u8_flag_500ms = 1;
 116   1      //  }
 117   1        
 118   1        //---1s--------------------------------------------
 119   1        if(u16_200ms_time_counter >= 5){                          //1s
 120   2          u16_200ms_time_counter = 0;
 121   2          u16_1s_time_counter ++; 
 122   2          u8_flag_1s = 1;
 123   2        }       
 124   1          //---2s--------------------------------------------
 125   1        if(u16_1s_time_counter >= 2){                             //2s
 126   2          u16_1s_time_counter = 0;
 127   2          u16_2s_time_counter ++; 
 128   2          u8_flag_2s = 1;
 129   2        } 
 130   1        
 131   1        count12ms++;
 132   1        if (count12ms >= MAX_12MS_CNT) {
 133   2          count12ms = 0;
 134   2        }
 135   1        if (b_triggered == 1) {
 136   2          if (count12ms == pulse_trigger_off_cnt) {
 137   3            ctr_triac_write_high();
 138   3            b_triggered = 0;
 139   3          }
 140   2        }
 141   1        
 142   1        _pop_(SFRS);
 143   1      }
 144          
 145          
 146          // interrupt for ADC
 147          
 148          void ADC_ISR(void) interrupt 11  // Vector @  0x5B
 149          {
 150   1        _push_(SFRS);
 151   1        clr_ADCCON0_ADCF;
 152   1        u16_adc_value = adc_read();
 153   1        u8_flag_adc = 1;
 154   1        _pop_(SFRS);
 155   1      }
 156          
 157          void Pin_INT_ISR(void) interrupt 7  // Vector @  0x3B
 158          {
 159   1        _push_(SFRS);
 160   1        
 161   1          // index pulse
 162   1        if (triac_pulse_cnt < MAX_TRIAC_PULSE - 1) {
 163   2          triac_pulse_cnt++;
 164   2        } else {
 165   2          triac_pulse_cnt = 0;
 166   2      
 167   2          if (additionInterval < MAX_ADDITION_INTERVAL - 1) {
 168   3            additionInterval++;
 169   3          } else {
 170   3            additionInterval = 0;
 171   3          }
 172   2        }
 173   1        
C51 COMPILER V9.60.7.0   ISR                                                               04/15/2024 16:51:39 PAGE 4   

 174   1          // update num_active_pulse_with_add
 175   1        if (additionInterval < num_addition) {
 176   2          num_active_pulse_with_add = num_active_pulse + 1;
 177   2          if (num_active_pulse_with_add > 20) {
 178   3            num_active_pulse_with_add = 20;
 179   3          }
 180   2        } else {
 181   2          num_active_pulse_with_add = num_active_pulse;
 182   2        }
 183   1        
 184   1        
 185   1        if (u16NumActive > 0) 
 186   1        {
 187   2           if (triac_pulse_cnt < num_active_pulse_with_add)
 188   2           {
 189   3             ctr_triac_write_low();
 190   3             b_triggered = 1;  // triac triggerd
 191   3             pulse_trigger_off_cnt = count12ms;
 192   3           }
 193   2         }
 194   1      
 195   1        
 196   1      //  u8_detect_zero++;
 197   1        
 198   1        PIF = 0;
 199   1        _pop_(SFRS);
 200   1      }
 201          
 202          
 203          
 204          void I2C_ISR(void) interrupt 6  // Vector @  0x3B
 205          {
 206   1        _push_(SFRS);
 207   1        SFRS = 0;
 208   1        if(I2CON & (1 << 3))
 209   1        {
 210   2          switch (I2STAT)
 211   2          {
 212   3               /* Bus error */
 213   3            case 0x00: 
 214   3              I2C_SET_STOP();
 215   3              break;
 216   3            
 217   3              /* I2C start */
 218   3            case 0x08: 
 219   3              I2DAT = addSlaveAndRW;
 220   3              I2C_CLEAR_START();  
 221   3              I2C_CLEAR_SI();   
 222   3              break;
 223   3            
 224   3            /* I2C repeat start */
 225   3            case 0x10:  
 226   3        //      I2C_SET_STOP(); 
 227   3              break;
 228   3            
 229   3            /* Master Transmit Address ACK  */
 230   3            case 0x18:
 231   3              I2DAT = m_tx_data[0];     
 232   3              break;
 233   3            
 234   3            /* Master Transmit Address NACK  */
 235   3            case 0x20:
C51 COMPILER V9.60.7.0   ISR                                                               04/15/2024 16:51:39 PAGE 5   

 236   3              I2C_SET_STOP(); 
 237   3              break;
 238   3            
 239   3            /* Master Transmit Data ACK  */
 240   3            case 0x28:   
 241   3              if(u8_cnt_data_tx == 0)
 242   3              {
 243   4                I2DAT = m_tx_data[1];
 244   4                u8_cnt_data_tx = 1;
 245   4              }
 246   3              else if(u8_cnt_data_tx == 1)
 247   3              {
 248   4                I2DAT = m_tx_data[2];
 249   4                u8_cnt_data_tx = 2;
 250   4              }
 251   3              else if(u8_cnt_data_tx == 2)
 252   3              {
 253   4                I2C_SET_STOP(); 
 254   4                u8_cnt_data_tx = 0;
 255   4                b_i2c_read_write = FLAG_READ;
 256   4              }
 257   3              break;
 258   3            
 259   3            /* Master Transmit Data NACK  */
 260   3            case 0x30:
 261   3        //      I2DAT = 0x55;
 262   3              I2C_SET_STOP();
 263   3              break;
 264   3            
 265   3            /* Master Arbitration Lost  */
 266   3            case 0x38:
 267   3              I2C_SET_STOP();
 268   3              break;
 269   3            
 270   3            
 271   3            
 272   3            /* Master Receive Address ACK  */
 273   3            case 0x40:
 274   3              I2C_SET_AA();
 275   3              break;
 276   3            
 277   3            /* Master Receive Address NACK  */
 278   3            case 0x48:
 279   3              I2C_SET_STOP();
 280   3              I2C_SET_AA();
 281   3              break;
 282   3            
 283   3            /* Master Receive Data ACK  */
 284   3            case 0x50:
 285   3              if(u8_cnt_data_rx == 0)
 286   3              {
 287   4                m_rx_data[0] = I2DAT;
 288   4                u8_cnt_data_rx = 1;
 289   4                I2C_SET_AA();
 290   4              }
 291   3              else if (u8_cnt_data_rx == 1)
 292   3              {
 293   4                m_rx_data[1] = I2DAT;
 294   4                u8_cnt_data_rx = 0;
 295   4                I2C_CLEAR_AA();
 296   4              }
 297   3              break;
C51 COMPILER V9.60.7.0   ISR                                                               04/15/2024 16:51:39 PAGE 6   

 298   3            
 299   3            /* Master Receive Data NACK  */
 300   3            case 0x58:
 301   3              m_rx_data[2] = I2DAT;
 302   3              b_i2c_read_write = FLAG_WRITE;
 303   3              b_flag_i2c_receive = 1;
 304   3              I2C_SET_STOP();
 305   3              I2C_SET_AA();
 306   3              break;
 307   3          }
 308   2            // clear SI
 309   2          I2C_CLEAR_SI();
 310   2        }
 311   1        _pop_(SFRS);
 312   1      }
 313          
 314          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    969    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     47    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
